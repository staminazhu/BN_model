#include <stdio.h>
#include <math.h>
#include <string.h>
#ifdef _WIN32
#include <direct.h>
#elif __linux__
#include <sys/stat.h>
#endif
#ifdef _WIN32
#define MKDIR(a) _mkdir((a))
#define ISNAN(a) _isnan((a))
#elif __linux__
#define MKDIR(a) mkdir((a),S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH)
#define ISNAN(a) isnan((a))
#endif
#define pi (4.*atan(1.0))
#define CFL (0.45) // CFL condition
#define M (1.)    // m=1 planar; m=2 cylindrical; m=3 spherical
#define Epsilon (1.) // r_0=Epsilon*dr
#include "./initdata_simple.h"
#define Md Ncell+5 // max vector dimension
#define Mt Tcell+5  // max theta dimension
#include "./inp.h"
#include "./Riemann.h"
#include "./VIPLimiter.h"
int main()
{	//parameters
	double GammaL=GAMMAL, GammaR=GAMMAR;
	double DL=DL0,DR=DR0,DM=DM0,UL=UL0,UR=UR0,VL,VR,PL=PL0,PR=PR0;//D:Density;U,V:Velocity;P:Pressure
	double CL,CR;//Sound speed
	CL=sqrt(GammaL*PL/DL);
	CR=sqrt(GammaR*PR/DR);
	if(2.0*CL/(GammaL-1.)+2.0*CR/(GammaR-1.)<=UR-UL)
		{
			printf("Error:Vacuum is generated by initial data!\n");
			return 0;
		}
	double dt; //delta_t
	static double F2[Md],F3[Md],E[Md],Speed1[Md],Speed2[Md];
	//flux, conservative variable and wave speed
	static double dRc[Md];//(derivative)centers distance
	double PM,UM,DML,DMR,Smax_deltar,time=0.;//P_star, U_star, rho_starL, roh_starR, max wave speed
	double dr,r;//initial d_raidus
	double dtheta,dtheta_plot;//initial d_angle
	dtheta=0.5*pi/Tcell;
	dtheta_plot=0.5*pi/Tcell_plot;
	static double RR[Md],DD[Md],UU[Md],PP[Md],CC[Md],GammaGamma[Md];//centroidal radius and variable in cells
	static double DdrL[Md],DdrR[Md],Ddr[Md];//distance from boundary to center in a cell
	static double Rb[Md],Lb[Md];//radius and length of outer cell boundary
	static double Rbh[Md],Lbh[Md];//h: half time step
	double Rb_NStep,Lb_NStep;
	//static double Rb_side[Md],Lb_side[Md],Rbh_side[Md],Lbh_side[Md],Sh[Md];
	static double mass[Md],vol[Md];
	FILE *out,*outs;
	//MKDIR(DATAOUT);
	char file_data[FILENAME_MAX];
	double plot_t=D_PLOT_T;
	int i,j,k;

	static double DmD[Md],DmU[Md],DmP[Md],TmV[Md];
	double slopeL,slopeR,DDL,DDR,DUL,DUR,DPL,DPR,TVL,TVR;//spacial derivative
	double C_star,DtU,DtP,DtDL,DtDR,TDSL,TDSR,DpsiL,DphiR,Us,Ps,Ds;//GRP variables
	static double Umin[Md],VLmin[Md],Pmin[Md],DLmin[Md],DRmin[Md];
	double sD,sU,sP,sV,C_starL,C_starR;
	static double F2P[Md];
	static double rb[Md][Mt],zb[Md][Mt],DD2[Md][Mt],UUxi2[Md][Mt],PP2[Md][Mt],GammaGamma2[Md][Mt];
	double VIP_lim, Vave[4][2], V0[2], Vp1[2], Vp2[2], Vp3[2];//VIP limiter
	int wrong_idx = 0;

	
	dr=(double)Domlen/Ncell;	
	for(i=0;i<=Ncell;i++)//center cell is cell 0
		Rb[i]=i*dr;//cell boundary
	for(i=0;i<Ncell;i++)//center cell is cell 0
		{
			RR[i]=(i+0.5)*dr;
			//centroid of triangular and trapezoid
			if(RR[i]<=Diaph1)
				{
					DD[i]=DL;
					UU[i]=UL;
					PP[i]=PL;
					GammaGamma[i]=GammaL;
				}
			else if(RR[i]<=Diaph2)
				{
					DD[i]=DM;
					UU[i]=UR;
					PP[i]=PR;
					GammaGamma[i]=GammaL;
				}
			else
				{
					DD[i]=DR;
					UU[i]=UR;
					PP[i]=PR;
					GammaGamma[i]=GammaR;
				}
			CC[i]=sqrt(GammaGamma[i]*PP[i]/DD[i]);
			E[i]=0.5*UU[i]*UU[i]+PP[i]/(DD[i]*(GammaGamma[i]-1.));
		}//initial value
	for(i=0;i<Ncell;i++)
		{
			DdrL[i]=Rb[i+1]-RR[i];
			DdrR[i]=RR[i]-Rb[i];
			vol[i] =DdrL[i]+DdrR[i];
			mass[i]=DD[i]*vol[i];
			if(i>=1)
				dRc[i] =RR[i]-RR[i-1];
		}
	Smax_deltar=0.;
	Smax_deltar=(Smax_deltar>(fabs(UL)+CL)/dr?Smax_deltar:(fabs(UL)+CL)/dr);
	Smax_deltar=(Smax_deltar>(fabs(UR)+CR)/dr?Smax_deltar:(fabs(UR)+CR)/dr);
	dt=CFL/Smax_deltar;

	for(i=0;i<Ncell;i++)
		{
			DmD[i]=0.;
			DmU[i]=0.;
			DmP[i]=0.;
		}
	for(k=1;k<=1e10;k++)
		{
			for(i=0;i<=Ncell;i++)
				{
					if (i==0 || i==Ncell)
						{
							if (i==0)
								j=0;
							else
								j=Ncell-1;
							GammaL = GammaGamma[j];
							GammaR = GammaGamma[j];
							DDL=0.;
							DDR=0.;
							DUL=0.;
							DUR=0.;
							DPL=0.;
							DPR=0.;
							DL=DD[j];
							DR=DD[j];
							UL=UU[j];
							UR=UU[j];
							PL=PP[j];
							PR=PP[j];
						}
					else
						{
							GammaL = GammaGamma[i-1];
							GammaR = GammaGamma[i];
							DDL=DmD[i-1];
							DDR=DmD[i];
							DUL=DmU[i-1];
							DUR=DmU[i];
							DPL=DmP[i-1];
							DPR=DmP[i];
							DL=DD[i-1]+DdrL[i-1]*DDL;
							DR=DD[i]  -DdrR[i]  *DDR;
							UL=UU[i-1]+DdrL[i-1]*DUL;
							UR=UU[i]  -DdrR[i]  *DUR;
							PL=PP[i-1]+DdrL[i-1]*DPL;
							PR=PP[i]  -DdrR[i]  *DPR;							
						}
					CL=sqrt(GammaL*PL/DL);
					CR=sqrt(GammaR*PR/DR);
					StarPU(PM,UM,DML,DMR,DL,DR,UL,UR,PL,PR,CL,CR,GammaL,GammaR);
					if(PM>PL)//left shock
						Speed1[i]=UL-CL*sqrt(PM/PL*(GammaL+1)/(2.*GammaL)+(GammaL-1.)/(2.*GammaL));
					else//left fan
						Speed1[i]=UL-CL;
					if(PM>PR)//right shock
						Speed2[i]=UR+CR*sqrt(PM/PR*(GammaR+1)/(2.*GammaR)+(GammaR-1.)/(2.*GammaR));
					else//right fan
						Speed2[i]=UR+CR;
				}
			Smax_deltar=0.;
			for(i=1;i<Ncell-1;i++)
				{
					Smax_deltar=(Smax_deltar>fabs(Speed1[i])/vol[i-1] ? Smax_deltar:fabs(Speed1[i])/vol[i-1]);
					Smax_deltar=(Smax_deltar>fabs(Speed2[i])/vol[i]   ? Smax_deltar:fabs(Speed2[i])/vol[i]);
				}
			dt=CFL/Smax_deltar;
			if(time<Timeout&&(time+dt)>Timeout)
				dt=Timeout-time;//compute for time step

			for(i=0;i<=Ncell;i++)
				{
					if (i==0 || i==Ncell)
						{
							if (i==0)
								j=0;
							else
								j=Ncell-1;
							GammaL = GammaGamma[j];
							GammaR = GammaGamma[j];
							DDL=0.;
							DDR=0.;
							DUL=0.;
							DUR=0.;
							DPL=0.;
							DPR=0.;
							DL=DD[j];
							DR=DD[j];
							UL=UU[j];
							UR=UU[j];
							PL=PP[j];
							PR=PP[j];
						}
					else
						{
							GammaL = GammaGamma[i-1];
							GammaR = GammaGamma[i];
							DDL=DmD[i-1];
							DDR=DmD[i];
							DUL=DmU[i-1];
							DUR=DmU[i];
							DPL=DmP[i-1];
							DPR=DmP[i];
							DL=DD[i-1]+DdrL[i-1]*DDL;
							DR=DD[i]  -DdrR[i]  *DDR;
							UL=UU[i-1]+DdrL[i-1]*DUL;
							UR=UU[i]  -DdrR[i]  *DUR;
							PL=PP[i-1]+DdrL[i-1]*DPL;
							PR=PP[i]  -DdrR[i]  *DPR;							
						}
					CL=sqrt(GammaL*PL/DL);
					CR=sqrt(GammaR*PR/DR);
					StarPU(PM,UM,DML,DMR,DL,DR,UL,UR,PL,PR,CL,CR,GammaL,GammaR);
					//Riemann_solver_exact(PM,UM,DML,DMR,DL,DR,UL,UR,PL,PR,CL,CR,GammaL,GammaR);
					TDSL=-CL*CL/(DL*(GammaL-1.))*DDL+1./(DL*(GammaL-1.))*DPL;
					TDSR=-CR*CR/(DR*(GammaR-1.))*DDR+1./(DR*(GammaR-1.))*DPR;
				   	GRPsolverSLag(DtDL,DtDR,DtU,DtP,UM,PM,DL,DR,UL,UR,PL,PR,DDL,DDR,DUL,DUR,DPL,DPR,TDSL,TDSR,0.0,0.0,1,GammaL,GammaR);
					Us=UM+0.5*dt*DtU;
					Ps=PM+0.5*dt*DtP;
					F2[i]=Ps;
					F3[i]=Ps*Us;
					Umin[i] =UM +dt*DtU;
					Pmin[i] =PM +dt*DtP;
					DLmin[i]=DML+dt*DtDL;
					DRmin[i]=DMR+dt*DtDR;
					Rb[i]   =Rb[i]+Us*dt;
				}
			for(i=0;i<Ncell;i++)
				{
					RR[i]  =0.5*(Rb[i+1]+Rb[i]);
					DdrL[i]=Rb[i+1]-RR[i];
					DdrR[i]=RR[i]-Rb[i];
					vol[i] =DdrL[i]+DdrR[i];
					DD[i]=mass[i]/vol[i];
					if(i>=1)
						dRc[i] =RR[i]-RR[i-1];
					if(vol[i]<0.)
						{
							printf("vol<0,error!\n");
							return 0;
						}
				}
			for(i=0;i<Ncell;i++)
				{
					UU[i]=UU[i]-dt/mass[i]*(F2[i+1]-F2[i]);
					E[i] =E[i] -dt/mass[i]*(F3[i+1]-F3[i]);
					PP[i]=(E[i]-0.5*UU[i]*UU[i])*(GammaGamma[i]-1.)*DD[i];
					if(ISNAN(PP[i])||ISNAN(UU[i])||ISNAN(DD[i]))
						{
							printf("variable is nan,error!\n");
							wrong_idx = 1;
						}
					else if (PP[i]<0)
						{
							printf("p<0,error!\n");
							wrong_idx = 1;
						}
				}
			if (wrong_idx)
				break;
			//VIP limiter update
			for(i=1;i<Ncell-1;i++)
				{
					sU=(Umin[i+1] -Umin[i]) /vol[i];
					sP=(Pmin[i+1] -Pmin[i]) /vol[i];
					sD=(DLmin[i+1]-DRmin[i])/vol[i];
					if (abs(LIMITER_CONF)==1)
						{
							DmD[i]=minmod(Alpha*(DD[i]-DD[i-1])/dRc[i],sD,Alpha*(DD[i+1]-DD[i])/dRc[i+1]);
							DmP[i]=minmod(Alpha*(PP[i]-PP[i-1])/dRc[i],sP,Alpha*(PP[i+1]-PP[i])/dRc[i+1]);
							DmU[i]=minmod(Alpha*(UU[i]-UU[i-1])/dRc[i],sU,Alpha*(UU[i+1]-UU[i])/dRc[i+1]);
						}
					else if (abs(LIMITER_CONF)==2)
						{
							DmD[i]=minmod(Alpha*(DD[i]-DD[i-1])/2./DdrR[i],sD,Alpha*(DD[i+1]-DD[i])/2./DdrL[i]);
							DmP[i]=minmod(Alpha*(PP[i]-PP[i-1])/2./DdrR[i],sP,Alpha*(PP[i+1]-PP[i])/2./DdrL[i]);
						   	DmU[i]=minmod(Alpha*(UU[i]-UU[i-1])/2./DdrR[i],sU,Alpha*(UU[i+1]-UU[i])/2./DdrL[i]);
						}
				}

			time=time+dt;
			printf("Time[%10d]=%e,dt=%e\n",k,time,dt);

			if(time-Timeout>EPS)
				break;
		}//end k

	outs=fopen("../datas_fin.m","w");
	fprintf(outs,"x=[");
	Write(outs,RR,Ncell);
	fprintf(outs,"];\n");
	fprintf(outs,"lo=[");
	Write(outs,DD,Ncell);
	fprintf(outs,"];\n");
	fprintf(outs,"u=[");
	Write(outs,UU,Ncell);
	fprintf(outs,"];\n");
	fprintf(outs,"p=[");
	Write(outs,PP,Ncell);
	fprintf(outs,"];\n");
	fprintf(outs,"gama=[");
	Write(outs,GammaGamma,Ncell);
	fprintf(outs,"];\n");
	fclose(outs);

	return 1;
}
